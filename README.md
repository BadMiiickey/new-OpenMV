本文将对目前OpenMV的控制代码进行简单的介绍。

一、 OpenMV官方封装库及其从属类、方法、属性
    官方文档地址: https://docs.singtown.com/micropython/zh/latest/openmvcam/index.html

    1. image
        首先，image的类型是Image，在sensor库(Image类从属于sensor库)下封装使用了大量对于OpenMV检测到的图像的分析方法。
        鉴于实际需求，目前仅使用了以下几种方法。

        (1) draw_rectangle
            作用是在目标位置渲染一个矩形框，可以自定义颜色，大小，位置等。
        (2) draw_string
            作用是在目标位置渲染文本，可以自定义文本内容，位置等。
        (3) get_statistics
            作用是获取当前图像的各类统计数据，从属方法或属性请自行翻阅官方文档。
        
    2. blob
        blob是一个数组，内部元素代表了这个像素的不同参数。
        实际上，blob有易于阅读的获取这些数据的方法，但是目前VSCode并不支持补全。

        对于blob，使用传统的list显然是不具备可读性的，数组的索引无法直接得知该元素代表的含义，因此，笔者使用了tuple元组形式存储blob，在解构blob时可以为每个元素声名变量，这能大大提高代码的可读性。

    3. sensor
        sensor库是OpenMV算法开发的核心库(大概)，很多关于识别到的图像处理方法都被封装在这个库下。
        具体方法和属性的介绍请移步官方文档，这对你的开发很有帮助。

二、MicroPython
    OpenMV v4.7.0; MicroPython v1.25.0-r0; OPENMV4P with STM32H743
    这是Openmv的版本，MicroPython是对Python3的轻量级实现，对于很多高版本的语法糖没有提供对应的支持(例如match-case)，因此编写时请使用基本的语法。

三、自定义的工具类
    为了增强代码规范性与可读性，笔者封装了大量工具类以便VSCode给出对应方法的补全提示，增强开发体验。
    那么为什么是工具类而非实体类呢？
    原因在于OpenMV是一个简单的硬件系统，控制部分也较为简单，没有涉及大量同种的控制元素，因此无需实例化，所有的变量和方法都作为类变量和类方法进行调用即可。
    这里需要注意的是，笔者使用了大量装饰器。对于没怎么接触过Python面向对象的开发者而言，装饰器可能有些陌生，但是装饰器是非常好用的，它可以大大简化可能在你的项目中出现的大量重复代码。在本项目中，主要使用的装饰器是@staticmethod和@classmethod，前者表示这是一个静态方法，被其装饰的函数不能直接使用self或者cls调用该类的属性、方法等，后者则表示其为类方法，可以使用cls调用该类中的属性、方法等。
    由于本项目涉及的对象均不具备实例化需求，因此基本全部使用@classmethod，以避免在主文件中实例化变量占用内存。

四、与STM32的通信协议
    目前定义UART3作为OpenMV与STM32的通信串口。
    OpenMV是输出端，write发送的string格式为'A0B *** *** C'，字母之间传输的是对应推进器占空比的10000倍(保留三位有效数字)。

五、与STP23(激光传感器)的通信协议
    目前定义UART1作为OpenMV与STP23的通信串口。
    读取STP23传递的数据是通过中断函数实现的，即__uartCallback函数封装了具体的拓展逻辑，irq启动。

六、未来开发提示
    以下是笔者的一点小想法~

    1. 开发体验部分
        如果你在使用非OpenMV IDE编辑器开发(官方编辑器实在太丑了)，对于OpenMV官方封装的许多库是没有办法正常给出补全提示的。那么有没有办法可以实现补全呢？答案是有的。

        (1) 使用VSCode插件
            味大无需多盐。
            (但是会拖慢VSCode的加载，至少我没用)
        (2) 使用pyi手动进行类型注释
            在某个文件夹下创建一个.pyi文件，在内部创建一个你要进行类型注释的类(例如Image)，采用@staticmethod注释和...手动将Image类下的所有方法重写为类似接口的形式，随后在你需要的地方导入该class，即可使用类型提示。
            至于为什么不使用functools的@dataclass，是因为OpenMV官方没有适配这个库(悲)。
            (不要问笔者为什么不做，问就是懒)
        (3) 为每个变量显式声明类型
            Python不像C/C++、Java、Typescript等必须要显式声明变量类型，它可以自动推导，但是在AI编程时代，养成一个良好的显式声明类型的习惯是非常有必要的，这可以大大减少调教AI的时间，并且对于代码的可读性也有比较高的提升。
        (4) 学习面向对象或面向函数编程
            大部分情况下，我们使用的都是面向过程编程——这是最直接、最简单的编程方式，但是一旦代码量变多，整个项目代码的可读性、扩展性就会遭到毁灭性打击。试想一下，如果这个项目使用面向过程编程，即把所有笔者独立出来的类全部塞到main主文件里，将会是一幅怎样的光景？
            因此，如果你对于编程有一定的追求，面向对象或是面向函数编程是你必须要学会的编程方式。

    2. 硬件拓展部分
        目前OpenMV作为识别模块，STM32作为控制模块，OpenMV有一块洞洞板可供拓展。实际上的拓展性是非常高的。

        
        












调试方法：
1. 如果船撞向泳圈的边缘（行驶不到中心），就降对应颜色的标准置信度
    理由：pid需要x方向上的偏差计算转向，这个x的计算需要目标物的x坐标。目前目标物的x坐标计算使用了加权平均，即通过标准置信度过滤图像上的每一个像素，对所有通过标准置信度过滤的像素执行加权平均，权重为其置信度。降低对应的标准置信度可以使更多像素参与加权平均计算，对于目标物的坐标确定会更有帮助。
2. 如果船前进断断续续，就降对应颜色的标准置信度
3. 如果船撞到目标LED不变色，就降对应颜色的标准色块面积
    如果降低标准色块面积仍然无效，需要校准颜色阈值

正常现象：
1. 转圈到摄像头正对目标时，船会停顿一下，可能前进可能不前进
    解释：停顿是我设置的对抗原先转圈惯性的措施，此时可以简单认为openmv在确认目标状态。如果一直停顿不前进，可能是由于标准置信度过高